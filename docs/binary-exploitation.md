# Binary Exploitation

The focus of this page is x86 and amd64 on Linux, but there is information from other architectures and operating systems sprinkled around.

## General References

Here are some general references to start you on your journey:

* [pwnable.tw](https://pwnable.tw/): a collection of binary exploitation challenges
* [LiveOverflow's YouTube channel](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w): hours and hours of amazing binary exploitation content

## Static Analysis

TODO

## Linux Syscalls

### Comparison to Other Architectures

TODO

### Virtual Dynamic Shared Object (vDSO)

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### Manual Syscalls

TODO: https://linux-kernel-labs.github.io/master/lectures/syscalls.html

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### x86 versus amd64

One of the main differences between x86 and amd64 is the standard method of invoking syscalls.

TODO: https://stackoverflow.com/a/12806910

### x86 Specifics

#### Syscall Table Reference

Look [here](https://syscalls.kernelgrok.com/).

### amd64 Specifics

#### Syscall Table Reference

Look [here](https://filippo.io/linux-syscall-table/).

### File Path Racing with `renameat`

If you notice multiple accesses to a file path, you might be able to exploit a race condition. This is really just a small subset of the [TOCTTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) problem. Luckily, there is a Linux syscall for quickly swapping the names of two files: [renameat](http://man7.org/linux/man-pages/man2/rename.2.html).

LiveOverflow has [an awesome video](https://www.youtube.com/watch?v=5g137gsB9Wk) explaining the concepts behind and implementation of an exploit for one of these race conditions. A basic program for running this race between two file paths is (from a 35C3 CTF [challenge](https://github.com/sroettger/35c3ctf_chals/tree/master/logrotate/exploit)):

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

int main(int argc, char ** argv) {
    while (1) {
        syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
    }

    return 0;
}
```

## `seccomp`

Secure Computing (i.e., [`seccomp`](http://man7.org/linux/man-pages/man2/seccomp.2.html)) is a facility implemented by the Linux kernel for transitioning a process to a "secure" state. Part of this "secure" state is filtering out syscalls so that they can no longer be executed.

A nice writeup of `seccomp` as it pertains to syscall filtering can be found [here](https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt)>

### `seccomp-tools`

The command-line tool [`seccomp-tools`](https://github.com/david942j/seccomp-tools) should be your first step for these types of challenges. Specifically, the `dump` sub-command will give you an idea of what syscalls are blocked by the binary's filter.

Because the analysis of this tool is performed via [`ptrace`](http://man7.org/linux/man-pages/man2/ptrace.2.html), you may have to patch binaries with anti-debugging measures in-place for `seccompt-tools` to work correctly.

### 32-bit Syscall ABI Filter Bypasses

These bypasses apply to `amd64` binaries and involve executing 32-bit ABI versions of syscalls rather than their 64-bit ABI equivalents.

The first technique involves switching to 32-bit ABI mode via the `retf` instruction. This instruction allows for switching to 32-bit mode via modification of the `CS` register. A writeup that includes this process can be found [here](https://web.archive.org/web/20181118183828/https://uaf.io/exploitation/2016/09/06/TokyoWesterns-MMA-Diary.html). If the filter does not check the architecture, then this technique is feasible.

If the challenge is an `amd64` binary and is not using [`libseccomp`](https://github.com/seccomp/libseccomp) for setting up its filters, there is a decent chance you can bypass the filters using 32-bit ABI syscalls directly. This can be achieved by `OR`-ing the syscall number with `0x40000000`, as 32-bit syscalls have the 30th MSB set high. Writeups that exploit this fact can be found [here](https://web.archive.org/web/20200209145642/http://blog.redrocket.club/2019/04/11/midnightsunctf-quals-2019-gissa2/) and [here](https://web.archive.org/web/20200209150956/https://ctftime.org/writeup/18236).

### Creative "Gadgets"

If bypassing the filter is not possible, it is probably possible to leak the flag using a syscall that is not filtered out. [This repository](https://github.com/unixist/seccomp-bypass) has some shellcodes that use syscalls like [`sendfile`](http://man7.org/linux/man-pages/man2/sendfile.2.html) to exfiltrate a flag file's contents.

## Stack Exploitation

TODO

## Windows Kernel Drivers

TODO
