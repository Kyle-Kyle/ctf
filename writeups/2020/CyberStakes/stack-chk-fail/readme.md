# Stack Chk Fail

The name and description of this challenge immediately reminded me of [this LiveOverflow video](https://www.youtube.com/watch?v=wLsckMfScOg), which covers a challenge from [32C3 CTF](https://ctftime.org/event/278). The relevant concepts are also discussed in [this writeup](https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200).

The gist of these solutions is abusing the implementation of glibc's `__stack_chk_fail` function, which gets called if a stack canary check fails (likely due to a stack-based buffer overflow). The error message printed by `__stack_chk_fail` includes the name of the program where the error occurred, which is pulled from the string buffer located at `__libc_argv[0]`. However, `__libc_argv[0]` is also stored on the stack. If we can overflow a stack-based buffer sufficiently, we can overwrite `__libc_argv[0]` to point to any valid memory location, whose string contents will then be printed when we trigger execution of `__stack_chk_fail` by smashing the stack canary. Since the flag will be stored at a known memory address, we can simply overwrite `__libc_argv[0]` with the flag's address. This kind of information leak attack is described well [here](https://seclists.org/bugtraq/2010/Apr/243).
