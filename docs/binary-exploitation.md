# Binary Exploitation

The focus of this page is x86 and amd64 on Linux, but there is information from other architectures and operating systems sprinkled around.

## General References

Here are some general references to start you on your journey:

* [pwnable.tw](https://pwnable.tw/): a collection of binary exploitation challenges
* [LiveOverflow's YouTube channel](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w): hours and hours of amazing binary exploitation content

## Static Analysis

TODO

## Linux Syscalls

### Comparison to Other Architectures

TODO

### Virtual Dynamic Shared Object (vDSO)

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### Manual Syscalls

TODO: https://linux-kernel-labs.github.io/master/lectures/syscalls.html

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### x86 versus amd64

One of the main differences between x86 and amd64 is the standard method of invoking syscalls.

TODO: https://stackoverflow.com/a/12806910

### x86 Specifics

#### Syscall Table Reference

Look [here](https://syscalls.kernelgrok.com/).

### amd64 Specifics

#### Syscall Table Reference

Look [here](https://filippo.io/linux-syscall-table/).

### File Path Racing with `renameat`

If you notice multiple accesses to a file path, you might be able to exploit a race condition. This is really just a small subset of the [TOCTTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) problem. Luckily, there is a Linux syscall for quickly swapping the names of two files: [renameat](http://man7.org/linux/man-pages/man2/rename.2.html).

LiveOverflow has [an awesome video](https://www.youtube.com/watch?v=5g137gsB9Wk) explaining the concepts behind and implementation of an exploit for one of these race conditions. A basic program for running this race between two file paths is (from a 35C3 CTF [challenge](https://github.com/sroettger/35c3ctf_chals/tree/master/logrotate/exploit)):

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

int main(int argc, char ** argv) {
    while (1) {
        syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
    }

    return 0;
}
```

## Stack Exploitation

TODO

## Windows Kernel Drivers

TODO
