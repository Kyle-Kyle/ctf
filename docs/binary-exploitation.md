# Binary Exploitation

The focus of this page is x86 and amd64 on Linux, but there is information from other architectures and operating systems sprinkled around.

## General References

Here are some general references to start you on your journey:

* [pwnable.tw](https://pwnable.tw/): A collection of binary exploitation challenges.
* [LiveOverflow's YouTube channel](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w): Hours and hours of amazing binary exploitation content.
* [Computer Tyme Interrupt Jump Table](http://www.ctyme.com/intr/int.htm): A reference of different interrupt codes and what they mean on different architectures.

## Static Analysis

TODO

## Dynamic Analysis

### GNU Project Debugger (GDB)

GDB (with the [GEF plugin](https://gef.readthedocs.io)) is my go-to debugger for ELF files.

#### Commands

The following table has some useful vanilla GDB basic commands and snippets that I always forget:

| Command                  | Description                                      |
| ------------------------ | ------------------------------------------------ |
| `step`                   | Step-into by source line.                        |
| `stepi`                  | Step-into by instruction.                        |
| `next`                   | Step-over by source line.                        |
| `nexti`                  | Step-over by instruction.                        |
| `info functions <regex>` | Show names and types of defined functions.       |
| `info variables <regex>` | Show names and types of global/static variables. |

The following table is the same as above, but for GEF:

| Command                  | Description                                       |
| ------------------------ | ------------------------------------------------- |
| `grep <string>`          | Search for a string in memory.                    |
| `xref 0xdeadbeef`        | Search for an address in memory.                  |
| `entry-break`            | Find a reasonable entrypoint and pause execution. |

#### Handling Syscalls and Signals

GDB has native support for interacting with a debugged program's syscalls and signals. Here are a couple of potentially-useful snippets:

```gdb
# Disable ptrace anti-debugging.
catch syscall ptrace
commands
    silent
    set $rax = 0
    continue
end

# Don't let the debugged program timeout.
handle SIGALRM ignore
```

Some of these techniques are demonstrated in [this PicoCTF 2018 writeup](https://syedfarazabrar.com/2019-07-14-picoctf-2018-be-quick-or-be-dead-3/).

#### Dumping Memory

When attached to a process, you can dump the contents of its memory in GDB. A potentially useful scenario for this technique is when dealing with a self-modifying binary. Here is the synax:

```gdb
dump memory ./outfile 0xdeadbeef 0xcafebabe
```

A writeup which does this can be found [here](https://nankeen.me/posts/plaid-ctf-2020-reee/).

## Shellcoding

### General References

For most challenges, a shellcode payload can be constructed from the [`pwnlib.shellcraft`](https://docs.pwntools.com/en/stable/shellcraft.html) module.

## Linux Syscalls

### Comparison to Other Architectures

TODO

### Virtual Dynamic Shared Object (vDSO)

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### Manual Syscalls

TODO: https://linux-kernel-labs.github.io/master/lectures/syscalls.html

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

### x86 versus amd64

One of the main differences between x86 and amd64 is the standard method of invoking syscalls.

TODO: https://stackoverflow.com/a/12806910

### x86 Specifics

#### Syscall Table Reference

Look [here](https://syscalls.kernelgrok.com/).

### amd64 Specifics

#### Syscall Table Reference

Look [here](https://filippo.io/linux-syscall-table/).

### File Path Racing with `renameat`

If you notice multiple accesses to a file path, you might be able to exploit a race condition. This is really just a small subset of the [TOCTTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) problem. Luckily, there is a Linux syscall for quickly swapping the names of two files: [renameat](http://man7.org/linux/man-pages/man2/rename.2.html).

LiveOverflow has [an awesome video](https://www.youtube.com/watch?v=5g137gsB9Wk) explaining the concepts behind and implementation of an exploit for one of these race conditions. A basic program for running this race between two file paths is (from a 35C3 CTF [challenge](https://github.com/sroettger/35c3ctf_chals/tree/master/logrotate/exploit)):

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

int main(int argc, char ** argv) {
    while (1) {
        syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
    }

    return 0;
}
```

## Understanding ELFs

### Overview

The [Executable and Linkable Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) is an executable file format for standalone binaries, shared libraries, and core dumps often used on Unix systems. One of the best ways to understand its details are in Linux's [`elf.h` source](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h).

### Hand-rolling ELFs

The quintessential reference for writing your own ELFs from hand is [The Teensy Files](https://www.muppetlabs.com/~breadbox/software/tiny/), which is a collection of articles exploring how to create the smallest possible ELF binary.

The [golf.so challenge](https://ctftime.org/task/11305) from Plaid CTF 2020 involved making a minimal shared object ELF (< 200 bytes) that ran an `execve` shellcode. Teams took a few different approaches, each of which is a good reference:

* [sigflag](https://www.sigflag.at/blog/2020/writeup-plaidctf2020-golfso/): This team actually wrote their solution in a C harness that used `elf.h`.
* [TeamGreyFang](https://github.com/TeamGreyFang/CTF-Writeups/tree/master/PlaidCTF2020/golf.so): An example of a nasm ELF payload, which ends with some overlapped sections and `DT_INIT` definition to get a sub-200-byte solution.

This challenge required slight modifications to the templates provided from The Teensy Files, due to the challenge involving creating a dynamic shared object. Look [here](https://docs.oracle.com/cd/E19455-01/816-0559/chapter6-42444/index.html) for a nice reference on the ELF dynamic section.

### `pwntools`'s `DynElf`

With a single arbitrary read primitive, lots of information can be determined about how an ELF is setup in memory. An interface that makes gleaning this information much simpler is `pwntools`'s [`DynElf` class](https://docs.pwntools.com/en/stable/dynelf.html). The `pwntools` documentation has some nice examples, but the following resources are a nice supplement:

* [StackOverflow: ELF link_map when linked as RELRO](https://reverseengineering.stackexchange.com/questions/6525/elf-link-map-when-linked-as-relro): A question from one of the `pwntools` authors about how to find an ELF's in-memory `link_map` structure.
* [Persian Challenge Writeup](https://hack.more.systems/writeup/2016/12/18/sharifctf7-guess-persian-nomoreblind/): A CTF writeup that uses `DynElf` and a format-string-powered read primitive to leak the challenge binary.
* [https://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html](https://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html): A blog post that explores implementing some of `DynElf`'s functionality by hand.

## Sandboxing

### `seccomp`

Secure Computing (i.e., [`seccomp`](http://man7.org/linux/man-pages/man2/seccomp.2.html)) is a facility implemented by the Linux kernel for transitioning a process to a "secure" state. Part of this "secure" state is filtering out syscalls so that they can no longer be executed.

A nice writeup of `seccomp` as it pertains to syscall filtering can be found [here](https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt).

#### `seccomp-tools`

The command-line tool [`seccomp-tools`](https://github.com/david942j/seccomp-tools) should be your first step for these types of challenges. Specifically, the `dump` sub-command will give you an idea of what syscalls are blocked by the binary's filter.

Because the analysis of this tool is performed via [`ptrace`](http://man7.org/linux/man-pages/man2/ptrace.2.html), you may have to patch binaries with anti-debugging measures in-place for `seccompt-tools` to work correctly.

#### 32-bit Syscall ABI Filter Bypasses

These bypasses apply to `amd64` binaries and involve executing 32-bit ABI versions of syscalls rather than their 64-bit ABI equivalents.

The first technique involves switching to 32-bit ABI mode via the `retf` instruction. This instruction allows for switching to 32-bit mode via modification of the `CS` register. A writeup that includes this process can be found [here](https://web.archive.org/web/20181118183828/https://uaf.io/exploitation/2016/09/06/TokyoWesterns-MMA-Diary.html). If the filter does not check the architecture, then this technique is feasible.

If the challenge is an `amd64` binary and is not using [`libseccomp`](https://github.com/seccomp/libseccomp) for setting up its filters, there is a decent chance you can bypass the filters using 32-bit ABI syscalls directly. This can be achieved by `OR`-ing the syscall number with `0x40000000`, as 32-bit syscalls have the 30th MSB set high. Writeups that exploit this fact can be found [here](https://web.archive.org/web/20200209145642/http://blog.redrocket.club/2019/04/11/midnightsunctf-quals-2019-gissa2/) and [here](https://web.archive.org/web/20200209150956/https://ctftime.org/writeup/18236).

### Creative "Gadgets"

If bypassing the filter is not possible, it is probably possible to leak the flag using a syscall that is not filtered out. [This repository](https://github.com/unixist/seccomp-bypass) has some shellcodes that use syscalls like [`sendfile`](http://man7.org/linux/man-pages/man2/sendfile.2.html) to exfiltrate a flag file's contents.

### Overcoming Instruction Blacklists

TODO: http://tukan.farm/2018/01/06/nope/

## Stack Exploitation

TODO

### ret2libc Attacks

In the event that ASLR is enabled on target, the libc will be loaded with a random base address. This means your exploit will most likely require an information leak to determine the process's loaded libc's base address in memory. However, for some 32-bit binaries, LIBC base address brute-force can be a feasible option.

If you leak some addresses of symbols with known offsets from the remote target, the following resources can help you find the LIBC that the remote target is using:

* [libc.blukat.me](https://libc.blukat.me/): A web application that accepts partial addresses of different symbols and tells you what LIBC they correspond to.
* [libc-database](https://github.com/niklasb/libc-database): The project that powers the above website. Also provides a command-line interface for doing local analysis of LIBC symbol addresses.

Loading the target's libc (either provided or found from an online database) can be done in the following ways:

* In GDB, use `set environment LD_PRELOAD ./libc.so.6`
* In pwntools, use `p = process('./binary', envs=dict(LD_PRELOAD='./libc.so.6'))`

## Emulation

### QEMU

[QEMU](https://www.qemu.org/) is an amazing feat of engineering. QEMU is a processor emulator capable of full-system emulation, user-mode binary emulation, and virtualization. It is an awesome tool for running CTF binaries built for different architectures.

To dive into applications of QEMU for emulating processors, the best guide I've seen can be found [here](https://johv.dk/blog/bare-metal-assembly-tutorial.html).

#### Booting from an ISO

If you are given an ISO with a custom boot loader / OS, QEMU can handle it for you. I've found these snippets useful:

```sh
# Mount the ISO to do some analysis of the files, figure out the arch, etc.
sudo mount -o loop custom-os.iso /media/cdrom

# Unmount before booting.
sudo umount /media/cdrom

# Use QEMU to boot into the OS (arch-dependent).
qemu-system-x86_64 -drive format=raw,media=cdrom,readonly,file=custom-os.iso
```

#### Emulating Old Linux Distros

If you are dealing with a binary linked against an insanely old version of glibc, a quick win might just be firing it up in an equally old OS. These resources can help get you there:

* [qemu-images](https://github.com/palmercluff/qemu-images): This repo contains ready-to-go QEMU images for old distros. The quickest option to go with from this list.
* [Test driving old Linux distros](https://opensource.com/article/16/12/yearbook-linux-test-driving-distros): An article that boots some old Linux OS ISOs and coveres some details of the process.
* [soft.lafibre.info](https://soft.lafibre.info/): A website that hosts a lot of old OS ISOs.

When working with pre-existing QEMU disk images, it can be useful to write files into those images before booting them:

```sh
# Install dependencies.
sudo apt-get install libguestfs-tools

# Write a local file myfile.txt into the image.
virt-sysprep -a debian-3.0.r6.qcow2 --upload ./local/path/to/myfile.txt:/img/path/to/myfile.txt

# Boot our image with some port forwarding.
qemu-system-i386 -hda debian-3.0.r6.qcow2 -m 256 -net nic -net user,hostfwd=tcp::10022-:22 -net nic -net user,hostfwd=tcp::10022-:22
```

### Unicorn Engine

While QEMU is a great engine for full machine virtualization and execution of binary executable files (ELF, PE, etc.), the [Unicorn Engine](https://www.unicorn-engine.org/) is a project that can peform emulation at the processor statement level.

I usually find myself reaching for the [Python bindings](https://github.com/unicorn-engine/unicorn/tree/master/bindings/python), which include many examples for a variety of architectures.

### `kexec`-ing in Userspace

This isn't as much in the realm of emulation, but in my mind it fits into this section. For some challenges, being able to `kexec` into a new kernel in userpsace is useful. To do that, see the [kexec-tools](https://github.com/horms/kexec-tools) project. [This writeup](https://ctftime.org/writeup/19151) by the p4 tean goes over how to use it in some scenarios.

## PHP Exploitation

See [this link](https://www.blackarrow.net/disable-functions-bypasses-and-php-exploitation/) for a guide to PHP exploitation.

## Debugging on Windows

[x64dbg](https://x64dbg.com) is a nice FOSS debugger for Windows. See [this StackOverflow answer](https://reverseengineering.stackexchange.com/questions/22494/how-to-use-memory-address-information-from-idafree-to-set-a-breakpoint-in-x32dbg/22498#22498) for tips on aligning its loaded base address with other disassembly tools.

## Windows Kernel Drivers

TODO
